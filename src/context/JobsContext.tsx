// src/context/JobsContext.tsx
import { createContext, useContext, useEffect, useState, type ReactNode } from "react";
import { supabase } from "../services/supabase-client";
import { addJob as addJobAPI, updateJob as updateJobAPI, deleteJob as deleteJobAPI } from "../services/api";


interface CompanyData {
  name: string;
  description: string;
  contactEmail: string;
  contactPhone: string;
}


export interface Job {
  id: string;
  title: string;
  type: string;
  location: string;
  description: string;
  salary: string;
  company: CompanyData;
}


// id is omitted since it`s automatically generated by the db
type NewJobReq = Omit<Job, "id">;

/**
 * @interface JobsContext
 * @description provides access to both the raw data and the data filtered by user input.
 */
interface JobsContext {
  /** filtered jobs */
  jobs: Job[] | null; 
  originalJobs: Job[] | null; 
  loading: boolean;

  error: Error | null;
  /** Function to force a fresh fetch of all job listings from the database. */
  refreshJobs: () => Promise<void>;
  addJob: (newJob: NewJobReq) => Promise<void>;
  updateJob: (updatedJob: Job) => Promise<void>;
  deleteJob: (id: string) => Promise<void>;
  /** aka keyword search term entered by the user. */
  searchTerm: string;
  setSearchTerm: (term: string) => void;
  /** current selected job type filter ('Full-Time', 'Remote'....). */
  filterType: string;
  setFilterType: (type: string) => void;
}


const JobsContext = createContext<JobsContext | undefined>(undefined);

/**
 * @function JobsProvider
 * @description Provides job data, CRUD functionality, and filtering logic to all child components.
 *  * aka the Single Source of Truth for the job list, maintaining both a master list 
* (originalJobs) and a filtered view (`jobs`).
* *
 *  * * **Synchronization Strategy:** CRUD functions modify the `originalJobs` state directly for instant UI updates.
*
 * * **Filtering Strategy:** The exposed `jobs` list is dynamically computed from `originalJobs` and the current `searchTerm`/`filterType`.
*
 */
export const JobsProvider = ({ children }: { children: ReactNode }): JSX.Element => {
  const [_, setJobs] = useState<Job[] | null>(null);
  const [originalJobs, setOriginalJobs] = useState<Job[] | null>(null); 
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);
  const [searchTerm, setSearchTerm] = useState("");
  const [filterType, setFilterType] = useState("All");

  /**
   * @function refreshJobs
   * @description Fetches all job listings from Supabase API and updates (originalJobs).
   */
  const refreshJobs = async () => {
    try {
      setLoading(true);
     setError(null);
      const { data, error } = await supabase
        .from("jobs")
        .select()
        .order("created_at", { ascending: false }); 
      if (error) throw new Error(error.message);
        setOriginalJobs(data as Job[]);
    } catch (err) {
      setError(err as Error);
      // Note: since originalJobs is the primary state, setJobs here for is just for error handlin
      setJobs(null);
    } finally {
      setLoading(false);
    }
  };

  // Fetch jobs on initial component mount
  useEffect(() => {
    refreshJobs();
  }, []);

  /**
   * @function addJob
   * @description Submits a new job to the API and prepends the result to both local job lists.
   * @param {NewJobReq} newJob - The job data to be added.
   * @async
   */
  const addJob = async (newJob: NewJobReq) => {
    const data = await addJobAPI(newJob);
    setJobs((prev) => (prev ? [data, ...prev] : [data]));
    setOriginalJobs((prev) => (prev ? [data, ...prev] : [data]));
  };

  /**
   * @function updateJob
   * @description Submits an updated job to the API and replaces the old version in both local job lists.
   * @param {Job} updatedJob - The full job object with updated fields.
   * @async
   */
  const updateJob = async (updatedJob: Job) => {
    const data = await updateJobAPI(updatedJob);
    setJobs((prev) =>
      prev ? prev.map((job) => (job.id === data.id ? data : job)) : [data]
    );
    setOriginalJobs((prev) =>
      prev ? prev.map((job) => (job.id === data.id ? data : job)) : [data]
    );
  };

  /**
   * @function deleteJob
   * @description Deletes a job from the API and filters it out of both local job lists.
   * @param {string} id - The ID of the job to delete.
   * @async
   */
  const deleteJob = async (id: string) => {
    await deleteJobAPI(id);
    setJobs((prev) => (prev ? prev.filter((job) => job.id !== id) : prev));
    setOriginalJobs((prev) => (prev ? prev.filter((job) => job.id !== id) : prev));
  };

  /**
   * @variable filteredJobs
   * @description Computes the result by applying the keyword search and type filter 
   * against(`originalJobs`).
   */
  const filteredJobs =
    originalJobs?.filter((job) => {
      const matchesSearch =
        job.title.toLowerCase().includes(searchTerm.toLowerCase()) ||
        job.company.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
        job.location.toLowerCase().includes(searchTerm.toLowerCase());
      const matchesType = filterType === "All" || job.type === filterType;
      return matchesSearch && matchesType;
    }) ?? null;

  return (
    <JobsContext.Provider
      value={{
        jobs: filteredJobs,
        originalJobs,
        loading,
        error,
        refreshJobs,
        addJob,
        updateJob,
        deleteJob,
        searchTerm,
        setSearchTerm,
        filterType,
        setFilterType,
      }}
    >
      {children}
    </JobsContext.Provider>
  );
};

/**
 * @function useJobs
 * @description A custom hook that consumes the Jobs Context, providing access to
 * the job data (filtered), loading state, filter setters, and CRUD functions.
 * @returns {JobsContextType}
 * @throws {Error} If used outside of a JobsProvider.
 */
export const useJobs = (): JobsContext => {
  const context = useContext(JobsContext);
  if (!context) throw new Error("useJobs must be used within a JobsProvider");
  return context;
};